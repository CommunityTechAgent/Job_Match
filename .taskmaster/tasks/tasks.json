{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "Update Supabase Jobs Table Schema for Airtable Integration",
        "description": "Enhance the existing jobs table schema in Supabase to support Airtable integration with new fields and indexes.",
        "details": "1. Connect to Supabase database\n2. Add the following fields to the jobs table:\n   - airtable_id (text, unique): Primary identifier from Airtable\n   - last_sync_date (timestamp): When the job was last synced\n   - sync_status (text): Status of sync (pending, synced, error)\n   - data_source (text): Source of job data (airtable, manual, etc.)\n   - job_type (text): Full-time, part-time, contract, etc.\n   - experience_level (text): Entry, mid, senior, etc.\n   - industry (text): Industry category\n   - department (text): Department within company\n   - remote_friendly (boolean): Whether job is remote-friendly\n   - skills_required (array): Array of required skills\n   - priority (text): Job priority level\n   - expires_date (timestamp): When job posting expires\n3. Create indexes for:\n   - airtable_id (for fast lookups)\n   - sync_status (for filtering pending/error jobs)\n   - expires_date (for filtering active jobs)\n4. Update Row Level Security (RLS) policies to include new fields\n5. Test schema with sample data insertion",
        "testStrategy": "1. Verify all new fields are created with correct data types\n2. Test indexes by querying on indexed fields and checking query plans\n3. Validate RLS policies by testing access with different user roles\n4. Insert sample job data with all new fields and verify retrieval\n5. Test uniqueness constraint on airtable_id field",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Set Up Airtable Base and Schema Configuration",
        "description": "Create and configure the Airtable base with appropriate schema for job management.",
        "details": "1. Create new Airtable account or use existing one\n2. Generate Airtable Personal Access Token with appropriate permissions\n3. Create new base named 'JobMatch AI - Job Management'\n4. Set up Jobs table with the following fields:\n   - Job ID (Formula: Auto-number with prefix 'JOB-')\n   - Title (Single line text, required)\n   - Company (Single line text, required)\n   - Location (Single line text, required)\n   - Job Type (Single select: Full-time, Part-time, Contract, etc.)\n   - Experience Level (Single select: Entry, Mid, Senior, etc.)\n   - Salary Min (Currency)\n   - Salary Max (Currency)\n   - Description (Long text)\n   - Requirements (Long text)\n   - Status (Single select: Active, Inactive, Draft)\n   - Posted Date (Date)\n   - Expires Date (Date)\n   - Created By (Single line text)\n   - Last Sync (Date & time)\n   - Sync Status (Single select: Pending, Synced, Error)\n   - Industry (Single select)\n   - Department (Single select)\n   - Remote Friendly (Checkbox)\n   - Skills Required (Multiple select)\n   - Priority (Single select: High, Medium, Low)\n5. Create the following views:\n   - 'Active Jobs' (Status = Active, sorted by Posted Date)\n   - 'Pending Sync' (Sync Status = Pending or Error)\n   - 'Expiring Soon' (Expires Date within 7 days)\n   - 'By Company' (grouped by Company)\n6. Configure base permissions for team access",
        "testStrategy": "1. Verify all fields are created with correct data types and options\n2. Test formula field for Job ID generation\n3. Create sample job entries to validate field constraints\n4. Verify all views display correct filtered data\n5. Test team access permissions by inviting a test user\n6. Validate API access using the Personal Access Token",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Airtable API Integration Library",
        "description": "Create a library for interacting with the Airtable API to fetch and manage job data.",
        "details": "1. Create lib/airtable.js file with the following:\n   - Set up environment variables:\n     - AIRTABLE_API_KEY\n     - AIRTABLE_BASE_ID\n     - AIRTABLE_TABLE_NAME\n   - Initialize Airtable client with API key\n   - Implement fetchActiveJobs() function:\n     ```javascript\n     export async function fetchActiveJobs() {\n       try {\n         const records = [];\n         await base(AIRTABLE_TABLE_NAME)\n           .select({\n             filterByFormula: \"AND({Status} = 'Active', {Expires Date} >= TODAY())\",\n             sort: [{ field: 'Posted Date', direction: 'desc' }]\n           })\n           .eachPage((page, fetchNextPage) => {\n             records.push(...page);\n             fetchNextPage();\n           });\n         return records;\n       } catch (error) {\n         console.error('Error fetching jobs from Airtable:', error);\n         throw error;\n       }\n     }\n     ```\n   - Implement rate limiting handling (5 requests/second)\n   - Add functions for creating, updating, and deleting jobs\n2. Create lib/jobTransformer.js for data transformation:\n   - Implement function to convert Airtable record format to Supabase format\n   - Add data validation and sanitization\n   - Handle field mapping between systems",
        "testStrategy": "1. Unit test fetchActiveJobs() with mock Airtable responses\n2. Test rate limiting by making rapid sequential requests\n3. Verify error handling by simulating API failures\n4. Test data transformation with various job record formats\n5. Validate field mapping correctness with sample data\n6. Integration test with actual Airtable API using test credentials",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Build Basic Airtable to Supabase Sync System",
        "description": "Create an API endpoint for manually syncing jobs from Airtable to Supabase.",
        "details": "1. Create pages/api/jobs/sync.js with the following functionality:\n   - Implement protected route (admin only) using authentication middleware\n   - Fetch all active jobs from Airtable using fetchActiveJobs()\n   - Query existing jobs from Supabase for comparison\n   - Compare jobs to identify new, updated, and unchanged records\n   - Insert new jobs and update modified jobs in Supabase\n   - Update sync status and timestamp in both systems\n   - Return sync summary (added, updated, unchanged, errors)\n2. Implement error handling and logging:\n   - Catch and log API errors\n   - Track individual job sync failures\n   - Implement retry logic for failed jobs\n3. Add transaction support for batch operations\n4. Create basic admin UI component for triggering sync:\n   ```javascript\n   function SyncButton() {\n     const [isLoading, setIsLoading] = useState(false);\n     const [result, setResult] = useState(null);\n     \n     const handleSync = async () => {\n       setIsLoading(true);\n       try {\n         const response = await fetch('/api/jobs/sync', { method: 'POST' });\n         const data = await response.json();\n         setResult(data);\n       } catch (error) {\n         console.error('Sync failed:', error);\n         setResult({ error: error.message });\n       } finally {\n         setIsLoading(false);\n       }\n     };\n     \n     return (\n       <div>\n         <button \n           onClick={handleSync} \n           disabled={isLoading}\n           className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\"\n         >\n           {isLoading ? 'Syncing...' : 'Sync Jobs from Airtable'}\n         </button>\n         {result && <pre>{JSON.stringify(result, null, 2)}</pre>}\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Test protected route access with authenticated and unauthenticated requests\n2. Verify sync process with test data in both systems\n3. Test error handling by simulating API failures\n4. Validate transaction rollback on partial failures\n5. Test sync summary accuracy with various scenarios (new jobs, updates, no changes)\n6. Verify UI component renders correctly and handles loading/error states\n7. End-to-end test of full sync process with real data",
        "priority": "high",
        "dependencies": [
          11,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement File Upload System for Resumes",
        "description": "Connect the resume upload UI to Supabase Storage and implement file validation and processing.",
        "details": "1. Set up Supabase Storage bucket for resumes:\n   - Create 'resumes' bucket with private access\n   - Configure RLS policies for user-specific access\n2. Implement file upload component:\n   ```javascript\n   function ResumeUpload() {\n     const [file, setFile] = useState(null);\n     const [uploading, setUploading] = useState(false);\n     const [progress, setProgress] = useState(0);\n     const [error, setError] = useState(null);\n     const { user } = useAuth();\n     \n     const handleFileChange = (e) => {\n       const selectedFile = e.target.files[0];\n       if (validateFile(selectedFile)) {\n         setFile(selectedFile);\n         setError(null);\n       }\n     };\n     \n     const validateFile = (file) => {\n       // Check file type (PDF/DOCX)\n       const validTypes = ['application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];\n       if (!validTypes.includes(file.type)) {\n         setError('File must be PDF or DOCX format');\n         return false;\n       }\n       \n       // Check file size (5MB limit)\n       if (file.size > 5 * 1024 * 1024) {\n         setError('File size must be less than 5MB');\n         return false;\n       }\n       \n       return true;\n     };\n     \n     const uploadFile = async () => {\n       if (!file || !user) return;\n       \n       setUploading(true);\n       setProgress(0);\n       \n       try {\n         const fileExt = file.name.split('.').pop();\n         const fileName = `${user.id}-${Date.now()}.${fileExt}`;\n         const filePath = `${user.id}/${fileName}`;\n         \n         // Upload to Supabase Storage\n         const { data, error } = await supabase.storage\n           .from('resumes')\n           .upload(filePath, file, {\n             cacheControl: '3600',\n             upsert: true,\n             onUploadProgress: (progress) => {\n               setProgress(Math.round((progress.loaded / progress.total) * 100));\n             }\n           });\n           \n         if (error) throw error;\n         \n         // Update user profile with resume URL\n         const { error: updateError } = await supabase\n           .from('profiles')\n           .update({ resume_url: filePath, resume_updated_at: new Date() })\n           .eq('id', user.id);\n           \n         if (updateError) throw updateError;\n         \n         // Success\n         setFile(null);\n       } catch (error) {\n         console.error('Error uploading file:', error);\n         setError(error.message);\n       } finally {\n         setUploading(false);\n       }\n     };\n     \n     return (\n       <div className=\"p-4 border rounded\">\n         <h3 className=\"text-lg font-semibold mb-2\">Upload Resume</h3>\n         <input \n           type=\"file\" \n           accept=\".pdf,.docx,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document\" \n           onChange={handleFileChange} \n           disabled={uploading}\n         />\n         {error && <p className=\"text-red-500 text-sm mt-1\">{error}</p>}\n         {file && (\n           <div className=\"mt-2\">\n             <p>{file.name} ({Math.round(file.size / 1024)} KB)</p>\n             <button \n               onClick={uploadFile} \n               disabled={uploading}\n               className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded mt-2\"\n             >\n               {uploading ? `Uploading (${progress}%)` : 'Upload'}\n             </button>\n             {uploading && (\n               <div className=\"w-full bg-gray-200 rounded-full h-2.5 mt-2\">\n                 <div className=\"bg-blue-600 h-2.5 rounded-full\" style={{ width: `${progress}%` }}></div>\n               </div>\n             )}\n           </div>\n         )}\n       </div>\n     );\n   }\n   ```\n3. Implement secure file access with signed URLs:\n   - Create API endpoint for generating temporary signed URLs\n   - Implement access control based on user ownership\n4. Add file preview functionality for uploaded resumes",
        "testStrategy": "1. Test file validation with various file types and sizes\n2. Verify upload process with progress tracking\n3. Test error handling for invalid files and upload failures\n4. Validate RLS policies by attempting access to other users' files\n5. Test signed URL generation and expiration\n6. Verify file preview functionality for PDF and DOCX formats\n7. Test mobile responsiveness of upload interface",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Enhance Profile Management System",
        "description": "Improve the user profile system with image upload, comprehensive validation, and skills management.",
        "details": "1. Add profile image upload functionality:\n   - Configure Supabase Storage for profile images\n   - Implement image cropping and resizing\n   - Add avatar preview and selection UI\n2. Enhance profile data structure in Supabase:\n   - Add missing fields: bio, headline, education, experience_years\n   - Create skills junction table for many-to-many relationship\n3. Implement comprehensive form validation:\n   - Required fields validation\n   - Format validation for email, phone, etc.\n   - Character limits for text fields\n4. Create skills management interface:\n   - Implement skills search and selection component\n   - Add skill level rating (beginner, intermediate, expert)\n   - Enable adding/removing skills\n   - Store skills in normalized format\n5. Add profile completeness indicator:\n   - Calculate percentage based on filled fields\n   - Show visual progress indicator\n   - Provide suggestions for improving profile\n6. Implement profile data persistence:\n   - Auto-save functionality for form fields\n   - Optimistic UI updates with error recovery\n   - Loading states for async operations",
        "testStrategy": "1. Test profile image upload with various image formats and sizes\n2. Verify form validation with valid and invalid inputs\n3. Test skills management functionality (add, remove, update)\n4. Validate data persistence across page refreshes\n5. Test profile completeness calculation with various scenarios\n6. Verify auto-save functionality with network interruptions\n7. Test UI responsiveness on mobile devices\n8. Validate accessibility compliance with screen readers",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Simple Job Matching Algorithm",
        "description": "Build a basic keyword-based matching system using Airtable jobs and user profiles.",
        "details": "1. Create matching algorithm in lib/matching.js:\n   ```javascript\n   export function scoreJobMatch(job, userProfile) {\n     let score = 0;\n     const maxScore = 100;\n     \n     // Skills matching (50% of score)\n     const userSkills = new Set(userProfile.skills.map(s => s.name.toLowerCase()));\n     const jobSkills = new Set(job.skills_required.map(s => s.toLowerCase()));\n     \n     // Calculate skills overlap\n     let matchedSkills = 0;\n     if (jobSkills.size > 0) {\n       for (const skill of userSkills) {\n         if (jobSkills.has(skill)) matchedSkills++;\n       }\n       score += (matchedSkills / jobSkills.size) * 50;\n     } else {\n       // No skills specified, give partial score\n       score += 25;\n     }\n     \n     // Location matching (20% of score)\n     if (job.remote_friendly) {\n       // Remote jobs get full location score\n       score += 20;\n     } else if (userProfile.location) {\n       // Simple location matching (city or state)\n       const jobLocation = job.location.toLowerCase();\n       const userLocation = userProfile.location.toLowerCase();\n       \n       if (jobLocation.includes(userLocation) || userLocation.includes(jobLocation)) {\n         score += 20;\n       } else {\n         // Partial match for same state/region\n         const jobState = extractState(jobLocation);\n         const userState = extractState(userLocation);\n         if (jobState && userState && jobState === userState) {\n           score += 10;\n         }\n       }\n     }\n     \n     // Experience level matching (15% of score)\n     const experienceLevels = {\n       'entry': 0,\n       'junior': 1,\n       'mid': 2,\n       'senior': 3,\n       'lead': 4,\n       'executive': 5\n     };\n     \n     const userLevel = experienceLevels[userProfile.experience_level] || 0;\n     const jobLevel = experienceLevels[job.experience_level] || 0;\n     \n     // Exact match or one level difference\n     if (userLevel === jobLevel) {\n       score += 15;\n     } else if (Math.abs(userLevel - jobLevel) === 1) {\n       score += 10;\n     } else if (Math.abs(userLevel - jobLevel) === 2) {\n       score += 5;\n     }\n     \n     // Job type preference matching (15% of score)\n     if (userProfile.job_type_preference === job.job_type) {\n       score += 15;\n     } else if (!userProfile.job_type_preference) {\n       // No preference specified\n       score += 7.5;\n     }\n     \n     // Return normalized score and match details\n     return {\n       score: Math.min(Math.round(score), 100),\n       matchedSkills,\n       totalJobSkills: jobSkills.size,\n       locationMatch: score >= 10,\n       experienceMatch: userLevel === jobLevel\n     };\n   }\n   \n   function extractState(location) {\n     // Simple state extraction logic\n     // Could be enhanced with proper location parsing\n     const states = ['AL', 'AK', 'AZ', /* other state codes */];\n     for (const state of states) {\n       if (location.includes(` ${state}`) || location.endsWith(`, ${state}`)) {\n         return state;\n       }\n     }\n     return null;\n   }\n   ```\n2. Implement API endpoint for job matching:\n   - Create pages/api/matches/index.js\n   - Fetch user profile and skills\n   - Retrieve active jobs from Supabase\n   - Apply matching algorithm to each job\n   - Return sorted matches with scores\n3. Create match results display interface:\n   - Show match score as percentage\n   - Highlight matching skills\n   - Display match reasoning\n   - Add apply/save actions\n4. Implement basic filtering capabilities:\n   - Filter by minimum match score\n   - Filter by job type\n   - Filter by location\n   - Sort by match score, date, etc.",
        "testStrategy": "1. Unit test matching algorithm with various profile and job combinations\n2. Verify score calculation accuracy for different scenarios\n3. Test edge cases (empty skills, no location, etc.)\n4. Validate API endpoint with authenticated and unauthenticated requests\n5. Test filtering functionality with different criteria\n6. Verify sorting options work correctly\n7. Test match display interface with high and low scoring matches\n8. Validate performance with large number of jobs",
        "priority": "medium",
        "dependencies": [
          14,
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Set Up Basic Email Notification System",
        "description": "Implement email service integration with Resend.com and create notification templates for job matches.",
        "details": "1. Set up Resend.com integration:\n   - Create Resend.com account\n   - Generate API key\n   - Configure environment variables (RESEND_API_KEY)\n2. Create email service library (lib/email.js):\n   ```javascript\n   import { Resend } from 'resend';\n   \n   const resend = new Resend(process.env.RESEND_API_KEY);\n   \n   export async function sendJobMatchEmail(user, matches) {\n     if (!user.email) throw new Error('User email is required');\n     \n     // Only send top 5 matches\n     const topMatches = matches.slice(0, 5);\n     \n     // Generate match HTML\n     const matchesHtml = topMatches.map(match => `\n       <div style=\"margin-bottom: 20px; padding: 15px; border: 1px solid #e2e8f0; border-radius: 5px;\">\n         <h3 style=\"margin-top: 0; color: #1a202c;\">${match.job.title} at ${match.job.company}</h3>\n         <p style=\"margin: 5px 0; color: #4a5568;\">${match.job.location} | ${match.job.job_type}</p>\n         <div style=\"margin: 10px 0;\">\n           <span style=\"display: inline-block; padding: 5px 10px; background-color: ${getScoreColor(match.score)}; color: white; border-radius: 15px; font-size: 14px;\">\n             ${match.score}% Match\n           </span>\n         </div>\n         <p style=\"margin: 10px 0;\">${truncate(match.job.description, 150)}</p>\n         <a href=\"${process.env.NEXT_PUBLIC_APP_URL}/jobs/${match.job.id}\" style=\"display: inline-block; padding: 8px 16px; background-color: #3182ce; color: white; text-decoration: none; border-radius: 4px;\">View Job</a>\n       </div>\n     `).join('');\n     \n     try {\n       const { data, error } = await resend.emails.send({\n         from: 'JobMatch AI <matches@jobmatchai.com>',\n         to: user.email,\n         subject: `${topMatches.length} New Job Matches for You`,\n         html: `\n           <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\n             <div style=\"text-align: center; padding: 20px;\">\n               <img src=\"${process.env.NEXT_PUBLIC_APP_URL}/logo.png\" alt=\"JobMatch AI\" style=\"max-width: 150px;\" />\n             </div>\n             <div style=\"padding: 20px;\">\n               <h2 style=\"color: #1a202c;\">Hello ${user.name || 'there'},</h2>\n               <p style=\"color: #4a5568; line-height: 1.5;\">We've found ${topMatches.length} new job matches for you based on your profile and skills.</p>\n               \n               <div style=\"margin: 30px 0;\">\n                 ${matchesHtml}\n               </div>\n               \n               <div style=\"margin-top: 30px; padding-top: 20px; border-top: 1px solid #e2e8f0; text-align: center; color: #718096; font-size: 14px;\">\n                 <p>You're receiving this email because you signed up for job match notifications.</p>\n                 <p><a href=\"${process.env.NEXT_PUBLIC_APP_URL}/settings/notifications\" style=\"color: #3182ce;\">Update notification preferences</a> | <a href=\"${process.env.NEXT_PUBLIC_APP_URL}/unsubscribe?token=${generateUnsubscribeToken(user.id)}\" style=\"color: #3182ce;\">Unsubscribe</a></p>\n               </div>\n             </div>\n           </div>\n         `\n       });\n       \n       if (error) throw error;\n       return data;\n     } catch (error) {\n       console.error('Failed to send email:', error);\n       throw error;\n     }\n   }\n   \n   function getScoreColor(score) {\n     if (score >= 80) return '#48bb78'; // green\n     if (score >= 60) return '#4299e1'; // blue\n     if (score >= 40) return '#ed8936'; // orange\n     return '#a0aec0'; // gray\n   }\n   \n   function truncate(text, maxLength) {\n     if (!text) return '';\n     if (text.length <= maxLength) return text;\n     return text.substring(0, maxLength) + '...';\n   }\n   \n   function generateUnsubscribeToken(userId) {\n     // Simple token generation - in production use proper JWT\n     return Buffer.from(`${userId}:${Date.now()}`).toString('base64');\n   }\n   ```\n3. Create API endpoint for sending match notifications:\n   - Implement pages/api/notifications/send-matches.js\n   - Add authentication and rate limiting\n   - Fetch user's top matches\n   - Send email with matches\n4. Implement unsubscribe functionality:\n   - Create unsubscribe API endpoint\n   - Validate unsubscribe tokens\n   - Update user preferences in database",
        "testStrategy": "1. Test email sending with valid and invalid parameters\n2. Verify email template rendering with various match data\n3. Test unsubscribe token generation and validation\n4. Validate rate limiting for notification requests\n5. Test email delivery to various email providers\n6. Verify tracking pixel and link functionality\n7. Test unsubscribe flow end-to-end\n8. Validate error handling for failed email sends",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Automated Airtable Sync System",
        "description": "Create an automated system to regularly sync jobs between Airtable and Supabase using cron jobs.",
        "details": "1. Create lib/syncJobs.js with comprehensive sync logic:\n   ```javascript\n   import { fetchActiveJobs } from './airtable';\n   import { supabase } from './supabaseClient';\n   import { transformAirtableToSupabase } from './jobTransformer';\n   \n   export async function syncJobs() {\n     console.log('Starting job sync process...');\n     const syncStartTime = new Date();\n     const syncResults = {\n       added: 0,\n       updated: 0,\n       unchanged: 0,\n       errors: 0,\n       errorDetails: []\n     };\n     \n     try {\n       // Fetch active jobs from Airtable\n       const airtableJobs = await fetchActiveJobs();\n       console.log(`Fetched ${airtableJobs.length} active jobs from Airtable`);\n       \n       // Fetch existing jobs from Supabase\n       const { data: existingJobs, error } = await supabase\n         .from('jobs')\n         .select('id, airtable_id, updated_at')\n         .not('airtable_id', 'is', null);\n         \n       if (error) throw error;\n       \n       // Create lookup map for existing jobs\n       const existingJobsMap = new Map();\n       existingJobs.forEach(job => existingJobsMap.set(job.airtable_id, job));\n       \n       // Process each Airtable job\n       for (const airtableJob of airtableJobs) {\n         try {\n           const airtableId = airtableJob.id;\n           const transformedJob = transformAirtableToSupabase(airtableJob);\n           \n           // Check if job exists in Supabase\n           const existingJob = existingJobsMap.get(airtableId);\n           \n           if (!existingJob) {\n             // New job - insert into Supabase\n             const { error: insertError } = await supabase\n               .from('jobs')\n               .insert([\n                 {\n                   ...transformedJob,\n                   airtable_id: airtableId,\n                   last_sync_date: syncStartTime,\n                   sync_status: 'synced',\n                   data_source: 'airtable'\n                 }\n               ]);\n               \n             if (insertError) throw insertError;\n             syncResults.added++;\n           } else {\n             // Existing job - update if needed\n             const airtableUpdatedAt = new Date(airtableJob.fields['Last Modified']);\n             const supabaseUpdatedAt = new Date(existingJob.updated_at);\n             \n             // Only update if Airtable record is newer\n             if (airtableUpdatedAt > supabaseUpdatedAt) {\n               const { error: updateError } = await supabase\n                 .from('jobs')\n                 .update({\n                   ...transformedJob,\n                   last_sync_date: syncStartTime,\n                   sync_status: 'synced'\n                 })\n                 .eq('id', existingJob.id);\n                 \n               if (updateError) throw updateError;\n               syncResults.updated++;\n             } else {\n               // Job unchanged\n               syncResults.unchanged++;\n             }\n           }\n         } catch (jobError) {\n           console.error(`Error processing job ${airtableJob.id}:`, jobError);\n           syncResults.errors++;\n           syncResults.errorDetails.push({\n             airtableId: airtableJob.id,\n             error: jobError.message\n           });\n         }\n       }\n       \n       console.log('Sync completed successfully:', syncResults);\n       return syncResults;\n     } catch (error) {\n       console.error('Sync process failed:', error);\n       throw error;\n     }\n   }\n   ```\n2. Set up Vercel Cron job for automated syncing:\n   - Create pages/api/cron/sync-jobs.js endpoint\n   - Configure Vercel cron job to run every 4 hours\n   - Add authentication for cron job (secret key verification)\n   - Implement logging and error notification\n3. Create sync status dashboard component:\n   ```javascript\n   function SyncStatusDashboard() {\n     const [lastSync, setLastSync] = useState(null);\n     const [syncStats, setSyncStats] = useState(null);\n     const [isLoading, setIsLoading] = useState(true);\n     \n     useEffect(() => {\n       fetchSyncStatus();\n     }, []);\n     \n     const fetchSyncStatus = async () => {\n       setIsLoading(true);\n       try {\n         const { data, error } = await supabase\n           .from('jobs')\n           .select('last_sync_date, sync_status')\n           .order('last_sync_date', { ascending: false })\n           .limit(1);\n           \n         if (error) throw error;\n         \n         if (data && data.length > 0) {\n           setLastSync(new Date(data[0].last_sync_date));\n         }\n         \n         // Get sync stats\n         const { data: statsData, error: statsError } = await supabase\n           .from('jobs')\n           .select('sync_status, count')\n           .group('sync_status');\n           \n         if (statsError) throw statsError;\n         \n         const stats = {};\n         statsData.forEach(item => {\n           stats[item.sync_status] = item.count;\n         });\n         \n         setSyncStats(stats);\n       } catch (error) {\n         console.error('Error fetching sync status:', error);\n       } finally {\n         setIsLoading(false);\n       }\n     };\n     \n     const triggerManualSync = async () => {\n       setIsLoading(true);\n       try {\n         const response = await fetch('/api/jobs/sync', { method: 'POST' });\n         const result = await response.json();\n         console.log('Manual sync result:', result);\n         fetchSyncStatus(); // Refresh status after sync\n       } catch (error) {\n         console.error('Manual sync failed:', error);\n       } finally {\n         setIsLoading(false);\n       }\n     };\n     \n     return (\n       <div className=\"p-4 border rounded bg-white shadow-sm\">\n         <h2 className=\"text-xl font-semibold mb-4\">Sync Status</h2>\n         \n         {isLoading ? (\n           <p>Loading sync status...</p>\n         ) : (\n           <div>\n             <div className=\"mb-4\">\n               <p className=\"text-sm text-gray-600\">Last successful sync:</p>\n               <p className=\"font-medium\">\n                 {lastSync ? lastSync.toLocaleString() : 'Never synced'}\n               </p>\n             </div>\n             \n             {syncStats && (\n               <div className=\"grid grid-cols-3 gap-4 mb-4\">\n                 <div className=\"p-3 bg-green-100 rounded\">\n                   <p className=\"text-sm text-gray-600\">Synced</p>\n                   <p className=\"text-xl font-semibold\">{syncStats.synced || 0}</p>\n                 </div>\n                 <div className=\"p-3 bg-yellow-100 rounded\">\n                   <p className=\"text-sm text-gray-600\">Pending</p>\n                   <p className=\"text-xl font-semibold\">{syncStats.pending || 0}</p>\n                 </div>\n                 <div className=\"p-3 bg-red-100 rounded\">\n                   <p className=\"text-sm text-gray-600\">Errors</p>\n                   <p className=\"text-xl font-semibold\">{syncStats.error || 0}</p>\n                 </div>\n               </div>\n             )}\n             \n             <button\n               onClick={triggerManualSync}\n               disabled={isLoading}\n               className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\"\n             >\n               {isLoading ? 'Syncing...' : 'Sync Now'}\n             </button>\n           </div>\n         )}\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Test automated sync process with various Airtable data scenarios\n2. Verify cron job authentication and security\n3. Test error handling and recovery for partial sync failures\n4. Validate sync status dashboard with different sync states\n5. Test manual sync trigger functionality\n6. Verify logging and monitoring of sync processes\n7. Test performance with large job datasets\n8. Validate conflict resolution strategy with simultaneous updates",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Create Sync Status Dashboard and Admin Interface",
        "description": "Build an admin interface for monitoring and managing the Airtable sync process and job data.",
        "details": "1. Create admin dashboard page (pages/admin/index.js):\n   - Implement admin-only access control\n   - Add authentication check middleware\n   - Create dashboard layout with navigation\n2. Build sync status overview component:\n   - Display last sync timestamp\n   - Show sync statistics (total jobs, active jobs, sync errors)\n   - Add manual sync trigger button\n   - Display sync history log\n3. Implement job management interface:\n   - Create job listing with filtering and sorting\n   - Add job detail view with edit capability\n   - Implement job status management (activate/deactivate)\n   - Add bulk operations for job management\n4. Create sync error management:\n   - Display detailed error information\n   - Add retry functionality for failed jobs\n   - Implement error resolution tracking\n   - Create error notification system\n5. Add Airtable integration settings:\n   - Display current Airtable connection status\n   - Allow updating API keys and base IDs\n   - Add sync frequency configuration\n   - Implement test connection functionality\n6. Create job statistics and analytics:\n   - Display job posting trends\n   - Show match statistics by job\n   - Add user engagement metrics\n   - Create exportable reports",
        "testStrategy": "1. Test admin access control with various user roles\n2. Verify sync status display accuracy\n3. Test manual sync trigger and error handling\n4. Validate job management interface with CRUD operations\n5. Test error management and resolution workflow\n6. Verify Airtable integration settings updates\n7. Test analytics data accuracy and report generation\n8. Validate responsive design for different screen sizes\n9. Test accessibility compliance for admin interface",
        "priority": "low",
        "dependencies": [
          19
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-22T01:19:42.010Z",
      "updated": "2025-06-22T19:44:33.475Z",
      "description": "Tasks for master context"
    }
  }
}